/*
 * generated by Xtext
 */
package org.eclipsecon.expdsl.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipsecon.expdsl.expressions.AbstractElement
import org.eclipsecon.expdsl.expressions.And
import org.eclipsecon.expdsl.expressions.BoolConstant
import org.eclipsecon.expdsl.expressions.Comparison
import org.eclipsecon.expdsl.expressions.Equality
import org.eclipsecon.expdsl.expressions.Expression
import org.eclipsecon.expdsl.expressions.ExpressionsModel
import org.eclipsecon.expdsl.expressions.IntConstant
import org.eclipsecon.expdsl.expressions.Minus
import org.eclipsecon.expdsl.expressions.MulOrDiv
import org.eclipsecon.expdsl.expressions.Not
import org.eclipsecon.expdsl.expressions.Or
import org.eclipsecon.expdsl.expressions.Plus
import org.eclipsecon.expdsl.expressions.StringConstant
import org.eclipsecon.expdsl.expressions.Variable
import org.eclipsecon.expdsl.expressions.VariableRef
import org.eclipsecon.expdsl.typing.ExpressionsTypeProvider
import org.eclipsecon.expdsl.typing.ExpressionsTypeUtils

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ExpressionsGenerator implements IGenerator {

	@Inject extension ExpressionsTypeUtils
	@Inject extension ExpressionsTypeProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		resource.allContents.toIterable.filter(typeof(ExpressionsModel)).forEach[
			val origFileName = resource.URI.lastSegment
			val javaClassName = origFileName.substring(0, origFileName.lastIndexOf('.')).toFirstUpper
			fsa.generateFile('''expressions/«javaClassName».java''', 
				compileToJava(javaClassName)
			)
		]
	}

	def compileToJava(ExpressionsModel model, String javaClassName) {
		'''
		package expressions;
		
		@SuppressWarnings("all")
		public class «javaClassName» {
			public void eval() {
				«model.elements.map[compileToJava].join("")»
			}
		}
		'''
	}

	def String compileToJava(AbstractElement e) {
		if (e instanceof Variable) {
			'''
			«e.declaredType.javaRepresentation» «e.name» = «e.expression.compileToJava»;
			'''
		} else {
			'''
			System.out.println("" + «(e as Expression).compileToJava»);
			'''
		}
	}

	def String compileToJava(Expression e) {
		switch (e) {
			IntConstant: e.value.toString
			BoolConstant: e.value
			StringConstant: '''"«e.value»"'''
			// when you're here, you assume the program is valid
			Not: "!(" + e.expression.compileToJava + ")"
			MulOrDiv: {
				'''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
			}
			Minus: '''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
			Plus: '''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
			Equality: {
				if (e.left.inferredType.isString) {
					'''(«e.left.compileToJava».equals(«e.right.compileToJava») «e.op» true)'''
				} else {
					'''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
				}
			}
			And: '''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
			Or: '''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
			Comparison: {
				if (e.left.inferredType.isString) {
					'''(«e.left.compileToJava».compareTo(«e.right.compileToJava») «e.op» 0)'''
				} else {
					'''(«e.left.compileToJava» «e.op» «e.right.compileToJava»)'''
				}
			}
			VariableRef: {
				e.variable.name
			}
		}
	}

}
